#!/usr/bin/env node
/**
 * JOSCTL - JOS Orchestration Controller
 * Format version v0.0.7 — Specification maturity v0.1.0 (Alpha)
 * 
 * Orchestrates .jos services and pipelines.
 * Zero dependencies beyond Node.js built-ins.
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');
const readline = require('readline');

// AURORA Design System
const C = {
    reset: '\x1b[0m',
    bold: '\x1b[1m',
    dim: '\x1b[2m',
    purple: '\x1b[38;5;135m',
    magenta: '\x1b[38;5;198m',
    cyan: '\x1b[38;5;51m',
    blue: '\x1b[38;5;39m',
    white: '\x1b[38;5;255m',
    gray: '\x1b[38;5;245m',
    green: '\x1b[38;5;78m',
    red: '\x1b[38;5;196m',
    yellow: '\x1b[38;5;220m'
};

const JOS_HOME = path.join(process.env.HOME, '.jos');
const args = process.argv.slice(2);
const cmd = args[0];
const help = args.includes('-h') || args.includes('--help');
const dryRun = args.includes('--dry-run');

// Smart JOS binary detection
function findJosBinary() {
    // 1. Check if @josfox/jos is installed as dependency
    try {
        const josPkg = require.resolve('@josfox/jos/bin/jos');
        return { type: 'dependency', path: josPkg };
    } catch (e) { }

    // 2. Check global installation
    try {
        execSync('which jos', { stdio: 'pipe' });
        return { type: 'global', path: 'jos' };
    } catch (e) { }

    // 3. Check local monorepo path (for development)
    const localPath = path.resolve(__dirname, '../../jos/bin/jos');
    if (fs.existsSync(localPath)) {
        return { type: 'local', path: localPath };
    }

    // 4. Fallback to npx
    return { type: 'npx', path: 'npx @josfox/jos' };
}

// Get default orchestration path
function findDefaultOrchestration() {
    // Check local development path
    const localPath = path.resolve(__dirname, '../../jos/examples/release/orchestration.jos');
    if (fs.existsSync(localPath)) return localPath;

    // Check current directory
    if (fs.existsSync('orchestration.jos')) return path.resolve('orchestration.jos');

    // Check ~/.jos/orchestration.jos
    const homePath = path.join(JOS_HOME, 'orchestration.jos');
    if (fs.existsSync(homePath)) return homePath;

    return null;
}

const JOS_INFO = findJosBinary();
const DEFAULT_ORCH = findDefaultOrchestration();

function printBanner() {
    console.log(`
${C.purple}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C.reset}
${C.bold}josctl${C.reset} ${C.cyan}v1.0.0${C.reset} // Orchestration Controller
${C.gray}Format version v0.0.7 — Specification maturity v0.1.0 (Alpha)${C.reset}
${C.purple}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C.reset}
`);
}

function printHelp() {
    printBanner();
    console.log(`${C.bold}Usage:${C.reset} josctl <command> [options]

${C.bold}Commands:${C.reset}
  ${C.cyan}orchestration${C.reset}     Run the release orchestration
  ${C.cyan}run${C.reset} <file.jos>    Run a specific .jos artifact
  ${C.cyan}validate${C.reset} <file>   Validate a .jos artifact
  ${C.cyan}status${C.reset}            Show current status
  ${C.cyan}witness${C.reset}           View witness logs

${C.bold}Options:${C.reset}
  -h, --help          Show help for command
  --dry-run           Simulate without executing
  --flow <name>       Specify flow to run
  --insecure          Skip integrity verification

${C.bold}Examples:${C.reset}
  josctl orchestration             # Run default orchestration
  josctl orchestration -h          # Interactive menu
  josctl run my-artifact.jos       # Run specific artifact
  josctl witness                   # View recent logs
`);
}

// Load .jos artifact and parse
function loadArtifact(filePath) {
    if (!fs.existsSync(filePath)) return null;
    try {
        return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch (e) {
        return null;
    }
}

// Interactive menu for orchestration
async function interactiveMenu(artifact, artifactPath) {
    console.log(`\n${C.bold}${C.cyan}INTERACTIVE ORCHESTRATION MENU${C.reset}\n`);
    console.log(`${C.gray}Artifact: ${path.basename(artifactPath)}${C.reset}`);
    console.log(`${C.gray}ID: ${artifact.id_jos || 'N/A'}${C.reset}\n`);

    // List flows
    const flows = artifact.orchestration?.flows || {};
    const pipelines = artifact.orchestration?.pipelines || {};
    const allFlows = { ...flows, ...pipelines };
    const flowNames = Object.keys(allFlows);

    console.log(`${C.bold}Available Flows:${C.reset}`);
    flowNames.forEach((name, i) => {
        const flow = allFlows[name];
        const desc = flow.description || 'No description';
        const steps = flow.steps?.length || 0;
        console.log(`  ${C.cyan}${i + 1}.${C.reset} ${C.bold}${name}${C.reset} ${C.gray}(${steps} steps)${C.reset}`);
        console.log(`     ${C.dim}${desc}${C.reset}`);
    });

    console.log(`\n  ${C.yellow}${flowNames.length + 1}.${C.reset} View Task Definitions`);
    console.log(`  ${C.red}${flowNames.length + 2}.${C.reset} Exit\n`);

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    return new Promise((resolve) => {
        rl.question(`${C.purple}Select option: ${C.reset}`, (answer) => {
            rl.close();
            const choice = parseInt(answer);

            if (choice >= 1 && choice <= flowNames.length) {
                resolve({ action: 'run', flow: flowNames[choice - 1] });
            } else if (choice === flowNames.length + 1) {
                resolve({ action: 'view_defs' });
            } else {
                resolve({ action: 'exit' });
            }
        });
    });
}

// Show task definitions
function showDefinitions(artifact) {
    const defs = artifact.orchestration?.definitions || {};
    console.log(`\n${C.bold}Task Definitions:${C.reset}\n`);

    Object.entries(defs).forEach(([name, def]) => {
        console.log(`  ${C.cyan}${name}${C.reset} ${C.gray}(${def.type})${C.reset}`);
        if (def.description) console.log(`    ${C.dim}${def.description}${C.reset}`);
        if (def.command) console.log(`    ${C.gray}$ ${def.command.substring(0, 60)}${def.command.length > 60 ? '...' : ''}${C.reset}`);
        if (def.artifact) console.log(`    ${C.gray}→ ${def.artifact}${C.reset}`);
        console.log('');
    });
}

// Run artifact with jos
function runArtifact(artifactPath, flowName, options = {}) {
    const runArgs = ['run', artifactPath, '--flow', flowName];
    if (options.dryRun) runArgs.push('--dry-run');
    if (options.insecure) runArgs.push('--insecure');

    console.log(`\n${C.cyan}▶ Executing:${C.reset} jos ${runArgs.join(' ')}\n`);

    try {
        let cmd;
        switch (JOS_INFO.type) {
            case 'dependency':
                cmd = `node "${JOS_INFO.path}" ${runArgs.join(' ')}`;
                break;
            case 'global':
                cmd = `jos ${runArgs.join(' ')}`;
                break;
            case 'local':
                cmd = `node "${JOS_INFO.path}" ${runArgs.join(' ')}`;
                break;
            case 'npx':
            default:
                cmd = `npx @josfox/jos ${runArgs.join(' ')}`;
                console.log(`${C.dim}(Using npx - install @josfox/jos globally for faster execution)${C.reset}\n`);
                break;
        }
        execSync(cmd, { stdio: 'inherit' });
    } catch (e) {
        console.log(`\n${C.red}✖ Execution failed${C.reset}`);
        process.exit(1);
    }
}

// View witness logs
function viewWitness() {
    const runsDir = path.join(JOS_HOME, 'runs');
    if (!fs.existsSync(runsDir)) {
        console.log(`${C.yellow}No witness logs found at ${runsDir}${C.reset}`);
        return;
    }

    const runs = fs.readdirSync(runsDir).sort().reverse().slice(0, 10);
    console.log(`\n${C.bold}${C.cyan}WITNESS LOGS${C.reset} ${C.gray}(Recent 10 runs)${C.reset}\n`);

    runs.forEach((runId, i) => {
        const eventsPath = path.join(runsDir, runId, 'events.jsonl');
        if (!fs.existsSync(eventsPath)) return;

        const events = fs.readFileSync(eventsPath, 'utf8').trim().split('\n');
        const firstEvent = JSON.parse(events[0]);
        const lastEvent = JSON.parse(events[events.length - 1]);

        const status = lastEvent.type.includes('success') ? `${C.green}✓${C.reset}` :
            lastEvent.type.includes('fail') ? `${C.red}✖${C.reset}` : `${C.yellow}●${C.reset}`;

        console.log(`  ${status} ${C.cyan}${runId}${C.reset}`);
        console.log(`    ${C.dim}${events.length} events | ${firstEvent.type} → ${lastEvent.type}${C.reset}`);
    });
    console.log('');
}

// Show status
function showStatus() {
    printBanner();
    console.log(`${C.bold}System Status:${C.reset}\n`);

    // Check jos binary
    // Show JOS kernel status
    switch (JOS_INFO.type) {
        case 'dependency':
            console.log(`  ${C.green}✓${C.reset} jos kernel: ${C.gray}@josfox/jos (dependency)${C.reset}`);
            break;
        case 'global':
            console.log(`  ${C.green}✓${C.reset} jos kernel: ${C.gray}global installation${C.reset}`);
            break;
        case 'local':
            console.log(`  ${C.green}✓${C.reset} jos kernel: ${C.gray}${JOS_INFO.path}${C.reset}`);
            break;
        case 'npx':
        default:
            console.log(`  ${C.yellow}⚠${C.reset} jos kernel: ${C.gray}will use npx (slower)${C.reset}`);
            console.log(`    ${C.dim}Run: npm install -g @josfox/jos${C.reset}`);
            break;
    }

    // Check default orchestration
    if (fs.existsSync(DEFAULT_ORCH)) {
        const orch = loadArtifact(DEFAULT_ORCH);
        console.log(`  ${C.green}✓${C.reset} orchestration.jos: ${C.gray}${orch?.id_jos || 'loaded'}${C.reset}`);
    } else {
        console.log(`  ${C.yellow}⚠${C.reset} orchestration.jos not found`);
    }

    // Check witness logs
    const runsDir = path.join(JOS_HOME, 'runs');
    if (fs.existsSync(runsDir)) {
        const runCount = fs.readdirSync(runsDir).length;
        console.log(`  ${C.green}✓${C.reset} witness logs: ${C.gray}${runCount} runs recorded${C.reset}`);
    } else {
        console.log(`  ${C.dim}○${C.reset} witness logs: none yet`);
    }

    console.log('');
}

// Main command handler
async function main() {
    if (!cmd || (help && !args.some(a => !a.startsWith('-')))) {
        printHelp();
        return;
    }

    switch (cmd) {
        case 'orchestration': {
            printBanner();
            const artifact = loadArtifact(DEFAULT_ORCH);

            if (!artifact) {
                console.log(`${C.red}✖ Could not load orchestration.jos${C.reset}`);
                process.exit(1);
            }

            if (help) {
                const choice = await interactiveMenu(artifact, DEFAULT_ORCH);

                if (choice.action === 'run') {
                    runArtifact(DEFAULT_ORCH, choice.flow, { dryRun, insecure: args.includes('--insecure') });
                } else if (choice.action === 'view_defs') {
                    showDefinitions(artifact);
                } else {
                    console.log(`${C.dim}Exiting...${C.reset}`);
                }
            } else {
                const flowName = args.includes('--flow') ? args[args.indexOf('--flow') + 1] : 'publish_all';
                runArtifact(DEFAULT_ORCH, flowName, { dryRun, insecure: args.includes('--insecure') });
            }
            break;
        }

        case 'run': {
            printBanner();
            let targetFile = args[1];
            if (!targetFile) {
                console.log(`${C.red}✖ Usage: josctl run <file.jos>${C.reset}`);
                process.exit(1);
            }

            // Auto-append .jos extension if missing
            if (!targetFile.endsWith('.jos')) {
                targetFile = targetFile + '.jos';
            }

            const flowName = args.includes('--flow') ? args[args.indexOf('--flow') + 1] : 'main';
            runArtifact(targetFile, flowName, { dryRun, insecure: args.includes('--insecure') });
            break;
        }

        case 'validate': {
            printBanner();
            let targetFile = args[1];
            if (!targetFile) {
                console.log(`${C.red}✖ Usage: josctl validate <file.jos>${C.reset}`);
                process.exit(1);
            }

            // Auto-append .jos extension if missing
            if (!targetFile.endsWith('.jos')) {
                targetFile = targetFile + '.jos';
            }

            const validateArgs = [targetFile];
            if (args.includes('--insecure')) validateArgs.push('--insecure');
            if (args.includes('--verbose')) validateArgs.push('--verbose');

            try {
                execSync(`node "${JOS_BIN}" validate ${validateArgs.join(' ')}`, { stdio: 'inherit' });
            } catch (e) {
                process.exit(1);
            }
            break;
        }

        case 'witness':
            printBanner();
            viewWitness();
            break;

        case 'status':
            showStatus();
            break;

        default:
            printHelp();
            console.log(`${C.red}✖ Unknown command: ${cmd}${C.reset}\n`);
            process.exit(1);
    }
}

main().catch(e => {
    console.error(`${C.red}Error: ${e.message}${C.reset}`);
    process.exit(1);
});
